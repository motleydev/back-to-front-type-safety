"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = void 0;
const graphql_1 = require("graphql");
const Models_1 = require("../Models");
const Spec_1 = require("../Models/Spec");
const typeResolver_1 = require("./typeResolver");
const ParserUtils_1 = require("./ParserUtils");
class Parser {
    static findComments(schema) {
        const stripDocs = schema
            .split(`"""`)
            .filter((e, i) => i % 2 !== 1)
            .join('');
        return stripDocs
            .split('\n')
            .filter((s) => s.startsWith('#'))
            .map((s) => s.slice(1).trimStart());
    }
}
exports.Parser = Parser;
Parser.importSchema = (schema) => (0, graphql_1.buildASTSchema)((0, graphql_1.parse)(schema));
Parser.documentDefinitionToSerializedNodeTree = (d) => {
    if ((0, graphql_1.isTypeSystemDefinitionNode)(d) || (0, graphql_1.isTypeSystemExtensionNode)(d)) {
        if ('name' in d) {
            return {
                name: d.name.value,
                type: d.kind === 'DirectiveDefinition'
                    ? {
                        name: Models_1.TypeDefinitionDisplayMap[d.kind],
                        directiveOptions: d.locations.map((l) => l.value),
                    }
                    : {
                        name: Models_1.TypeDefinitionDisplayMap[d.kind],
                    },
                data: {
                    type: d.kind,
                },
                description: 'description' in d && d.description ? d.description.value : '',
                interfaces: 'interfaces' in d && d.interfaces ? d.interfaces.map((i) => i.name.value) : undefined,
                directives: 'directives' in d && d.directives ? typeResolver_1.TypeResolver.iterateDirectives(d.directives) : undefined,
                args: typeResolver_1.TypeResolver.resolveFieldsFromDefinition(d),
            };
        }
    }
};
Parser.parse = (schema, excludeRoots = [], libraries = '') => {
    var _a;
    let parsedSchema;
    const compiledSchema = [libraries, schema].join('\n');
    try {
        parsedSchema = (0, graphql_1.parse)(compiledSchema);
    }
    catch (error) {
        console.error(error);
    }
    if (!parsedSchema) {
        throw new Error('Cannot parse the schema');
    }
    const operations = {};
    const schemaDefinition = parsedSchema.definitions.find((d) => d.kind === 'SchemaDefinition');
    if (schemaDefinition && 'operationTypes' in schemaDefinition) {
        (_a = schemaDefinition.operationTypes) === null || _a === void 0 ? void 0 : _a.forEach((ot) => {
            if (ot.operation === 'query') {
                operations.Query = ot.type.name.value;
            }
            if (ot.operation === 'mutation') {
                operations.Mutation = ot.type.name.value;
            }
            if (ot.operation === 'subscription') {
                operations.Subscription = ot.type.name.value;
            }
        });
    }
    const nodes = parsedSchema.definitions
        .filter((t) => 'name' in t && t.name && !excludeRoots.includes(t.name.value))
        .map(Parser.documentDefinitionToSerializedNodeTree)
        .filter((d) => !!d);
    const comments = Parser.findComments(schema).map((description) => ({
        name: Spec_1.Helpers.Comment,
        type: {
            name: Spec_1.Helpers.Comment,
        },
        data: {
            type: Spec_1.Helpers.Comment,
        },
        description,
    }));
    const nodeTree = {
        nodes: [...comments, ...nodes],
    };
    nodeTree.nodes.forEach((n) => {
        var _a;
        if (((_a = n.data) === null || _a === void 0 ? void 0 : _a.type) === Spec_1.TypeDefinition.ObjectTypeDefinition) {
            if (operations.Query ? operations.Query === n.name : n.name === 'Query') {
                n.type.operations = [Spec_1.OperationType.query];
            }
            if (operations.Mutation ? operations.Mutation === n.name : n.name === 'Mutation') {
                n.type.operations = [Spec_1.OperationType.mutation];
            }
            if (operations.Subscription ? operations.Subscription === n.name : n.name === 'Subscription') {
                n.type.operations = [Spec_1.OperationType.subscription];
            }
        }
    });
    return nodeTree;
};
Parser.parseAddExtensions = (schema, excludeRoots = []) => {
    const parsed = Parser.parse(schema, excludeRoots);
    const Extensions = parsed.nodes.filter((n) => n.data.type && n.data.type in Spec_1.TypeExtension);
    if (!Extensions || Extensions.length === 0) {
        return parsed;
    }
    const nodes = parsed.nodes.filter((n) => !(n.data.type && n.data.type in Spec_1.TypeExtension));
    Extensions.forEach((e) => {
        const extendedNode = nodes.find((we) => ParserUtils_1.ParserUtils.isExtensionOf(e, we));
        if (!extendedNode) {
            throw new Error(`Invalid extension node`);
        }
        if (e.directives) {
            extendedNode.directives = [...(extendedNode.directives || []), ...e.directives];
        }
        if (e.interfaces) {
            extendedNode.interfaces = [...(extendedNode.interfaces || []), ...e.interfaces];
        }
        if (e.args) {
            extendedNode.args = [...(extendedNode.args || []), ...e.args];
        }
    });
    return { nodes };
};
__exportStar(require("./ParserUtils"), exports);
