"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeResolver = void 0;
const Models_1 = require("../Models");
const Spec_1 = require("../Models/Spec");
class TypeResolver {
    static resolveSingleField(n, options = []) {
        if (n.kind === 'ListType') {
            const opts = [...options, Models_1.Options.array];
            return Object.assign({ options: opts }, TypeResolver.resolveSingleField(n.type, opts));
        }
        if (n.kind === 'NonNullType') {
            const opts = [...options];
            if (opts.indexOf(Models_1.Options.required) >= 0 && opts.indexOf(Models_1.Options.array) >= 0) {
                opts.push(Models_1.Options.arrayRequired);
            }
            else {
                opts.push(Models_1.Options.required);
            }
            return Object.assign({ options: opts }, TypeResolver.resolveSingleField(n.type, opts));
        }
        return {
            name: n.name.value,
        };
    }
    static iterateObjectTypeFields(fields) {
        return fields.map((n) => ({
            name: n.name.value,
            description: n.description && n.description.value,
            args: n.arguments && TypeResolver.iterateInputValueFields(n.arguments),
            type: TypeResolver.resolveSingleField(n.type),
            directives: n.directives && TypeResolver.iterateDirectives(n.directives),
            data: {
                type: Spec_1.TypeSystemDefinition.FieldDefinition,
            },
        }));
    }
    static resolveObjectField(f) {
        return [
            {
                name: f.name.value,
                type: {
                    name: f.name.value,
                    options: TypeResolver.resolveInputValueOptions(f.value),
                },
                data: {
                    type: Spec_1.Instances.Argument,
                },
                args: TypeResolver.resolveValue(f.value),
            },
        ];
    }
    static resolveValue(value) {
        if (value.kind === 'ListValue') {
            return value.values.map(TypeResolver.resolveValue).reduce((a, b) => [...(a || []), ...(b || [])], []);
        }
        if (value.kind === 'ObjectValue') {
            return [
                {
                    name: value.kind,
                    args: value.fields.map((f) => TypeResolver.resolveObjectField(f)).reduce((a, b) => [...a, ...b], []),
                    data: {
                        type: value.kind,
                    },
                    type: {
                        name: value.kind,
                    },
                },
            ];
        }
        if (value.kind === 'EnumValue') {
            return [
                {
                    name: value.value,
                    data: {
                        type: value.kind,
                    },
                    type: {
                        name: value.value,
                    },
                },
            ];
        }
        if (value.kind in Spec_1.Value) {
            return [
                {
                    name: 'value' in value ? value.value.toString() : 'name' in value ? value.name.value : '',
                    type: {
                        name: value.kind,
                    },
                    data: {
                        type: value.kind,
                    },
                },
            ];
        }
        return undefined;
    }
    static iterateDirectives(directives) {
        return directives.map((n) => ({
            name: n.name.value,
            type: {
                name: n.name.value,
            },
            data: {
                type: Spec_1.Instances.Directive,
            },
            args: n.arguments ? TypeResolver.iterateArgumentFields(n.arguments) : [],
        }));
    }
    static iterateArgumentFields(fields) {
        return fields.map((n) => ({
            name: n.name.value,
            type: {
                name: n.name.value,
                options: TypeResolver.resolveInputValueOptions(n.value),
            },
            data: {
                type: Spec_1.Instances.Argument,
            },
            args: TypeResolver.resolveValue(n.value),
        }));
    }
    static iterateInputValueFields(fields) {
        return fields.map((n) => ({
            name: n.name.value,
            description: n.description && n.description.value,
            directives: n.directives && TypeResolver.iterateDirectives(n.directives),
            type: TypeResolver.resolveSingleField(n.type),
            data: {
                type: Spec_1.ValueDefinition.InputValueDefinition,
            },
            args: n.defaultValue ? TypeResolver.resolveValue(n.defaultValue) : undefined,
        }));
    }
    static resolveInterfaces(n) {
        if (n.kind !== 'ObjectTypeDefinition' || !n.interfaces) {
            return;
        }
        return n.interfaces.map((i) => i.name.value);
    }
    static resolveFields(n) {
        if (n.kind === 'EnumTypeDefinition') {
            if (!n.values) {
                return;
            }
            return n.values.map((v) => ({
                name: v.name.value,
                description: v.description && v.description.value,
                directives: v.directives && TypeResolver.iterateDirectives(v.directives),
                type: { name: Spec_1.ValueDefinition.EnumValueDefinition },
                data: {
                    type: Spec_1.ValueDefinition.EnumValueDefinition,
                },
            }));
        }
        if (n.kind === 'ScalarTypeDefinition') {
            return;
        }
        if (n.kind === 'UnionTypeDefinition') {
            if (!n.types) {
                return;
            }
            return n.types.map((t) => ({
                name: t.name.value,
                type: { name: t.name.value },
                data: {
                    type: Spec_1.TypeSystemDefinition.UnionMemberDefinition,
                },
            }));
        }
        if (n.kind === 'InputObjectTypeDefinition') {
            if (!n.fields) {
                return;
            }
            const fields = TypeResolver.iterateInputValueFields(n.fields);
            return fields;
        }
        if (!n.fields) {
            return;
        }
        const fields = TypeResolver.iterateObjectTypeFields(n.fields);
        return fields;
    }
    static resolveFieldsFromDefinition(n) {
        if ('values' in n && n.values) {
            return n.values.map((v) => ({
                name: v.name.value,
                description: v.description && v.description.value,
                directives: v.directives && TypeResolver.iterateDirectives(v.directives),
                type: { name: Spec_1.ValueDefinition.EnumValueDefinition },
                data: {
                    type: Spec_1.ValueDefinition.EnumValueDefinition,
                },
            }));
        }
        if ('types' in n && n.types) {
            return n.types.map((t) => ({
                name: t.name.value,
                type: { name: t.name.value },
                data: {
                    type: Spec_1.TypeSystemDefinition.UnionMemberDefinition,
                },
            }));
        }
        if ((n.kind === 'InputObjectTypeDefinition' || n.kind === 'InputObjectTypeExtension') && n.fields) {
            return TypeResolver.iterateInputValueFields(n.fields);
        }
        if ('arguments' in n && n.arguments) {
            return TypeResolver.iterateInputValueFields(n.arguments);
        }
        if (n.kind === 'ObjectTypeDefinition' ||
            n.kind === 'ObjectTypeExtension' ||
            n.kind === 'InterfaceTypeDefinition' ||
            n.kind === 'InterfaceTypeExtension') {
            if (!n.fields) {
                throw new Error('Type object should have fields');
            }
            return TypeResolver.iterateObjectTypeFields(n.fields);
        }
    }
}
exports.TypeResolver = TypeResolver;
TypeResolver.resolveInputValueOptions = (value) => {
    const options = [];
    if (value.kind === 'ListValue') {
        options.push(Models_1.Options.array);
    }
    return options;
};
