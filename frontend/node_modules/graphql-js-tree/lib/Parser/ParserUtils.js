"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParserUtils = void 0;
const Models_1 = require("../Models");
const compareArrays = (a1 = [], a2 = []) => a1.length === a2.length &&
    a1.sort().every((value, index) => {
        return value === a2.sort()[index];
    });
const extensionMap = {
    EnumTypeExtension: Models_1.TypeDefinition.EnumTypeDefinition,
    InputObjectTypeExtension: Models_1.TypeDefinition.InputObjectTypeDefinition,
    InterfaceTypeExtension: Models_1.TypeDefinition.InterfaceTypeDefinition,
    ObjectTypeExtension: Models_1.TypeDefinition.ObjectTypeDefinition,
    ScalarTypeExtension: Models_1.TypeDefinition.ScalarTypeDefinition,
    UnionTypeExtension: Models_1.TypeDefinition.UnionTypeDefinition,
};
class ParserUtils {
}
exports.ParserUtils = ParserUtils;
ParserUtils.compareParserFields = (node1, node2) => {
    if (node1.name !== node2.name ||
        node1.type.name !== node2.type.name ||
        !compareArrays(node1.type.directiveOptions, node2.type.directiveOptions) ||
        !compareArrays(node1.type.operations, node2.type.operations) ||
        !compareArrays(node1.type.options, node2.type.options) ||
        !compareArrays(node1.interfaces, node2.interfaces) ||
        !ParserUtils.compareParserTreesNodes(node1.directives, node2.directives) ||
        !ParserUtils.compareParserTreesNodes(node1.args, node2.args)) {
        return false;
    }
    return true;
};
ParserUtils.compareParserTreesNodes = (t1, t2) => {
    if (!t1) {
        if (!t2) {
            return true;
        }
        if (t2.length === 0) {
            return true;
        }
        return false;
    }
    if (!t2) {
        if (t1.length === 0) {
            return true;
        }
        return false;
    }
    for (const node1 of t1) {
        const compareResult = t2.find((node2) => ParserUtils.compareParserFields(node1, node2));
        if (!compareResult) {
            return false;
        }
    }
    return true;
};
ParserUtils.isExtensionOf = (extensionNode, extendedNode) => {
    if (extendedNode.name !== extensionNode.name) {
        return false;
    }
    if (extensionMap[extensionNode.data.type] !== extendedNode.data.type) {
        return false;
    }
    return true;
};
