export declare const constantTypesTypescript = "\nexport type UnwrapPromise<T> = T extends Promise<infer R> ? R : T;\nexport type ZeusState<T extends (...args: any[]) => Promise<any>> = NonNullable<\n  UnwrapPromise<ReturnType<T>>\n>;\nexport type ZeusHook<\n  T extends (\n    ...args: any[]\n  ) => Record<string, (...args: any[]) => Promise<any>>,\n  N extends keyof ReturnType<T>\n> = ZeusState<ReturnType<T>[N]>;\n\ntype WithTypeNameValue<T> = T & {\n  __typename?: true;\n};\ntype AliasType<T> = WithTypeNameValue<T> & {\n  __alias?: Record<string, WithTypeNameValue<T>>;\n};\nexport interface GraphQLResponse {\n  data?: Record<string, any>;\n  errors?: Array<{\n    message: string;\n  }>;\n}\ntype DeepAnify<T> = {\n  [P in keyof T]?: any;\n};\ntype IsPayLoad<T> = T extends [any, infer PayLoad] ? PayLoad : T;\ntype IsArray<T, U> = T extends Array<infer R> ? InputType<R, U>[] : InputType<T, U>;\ntype FlattenArray<T> = T extends Array<infer R> ? R : T;\n\ntype IsInterfaced<SRC extends DeepAnify<DST>, DST> = FlattenArray<SRC> extends ZEUS_INTERFACES | ZEUS_UNIONS\n  ? {\n      [P in keyof SRC]: SRC[P] extends '__union' & infer R\n        ? P extends keyof DST\n          ? IsArray<R, '__typename' extends keyof DST ? DST[P] & { __typename: true } : DST[P]>\n          : {}\n        : never;\n    }[keyof DST] &\n      {\n        [P in keyof Omit<\n          Pick<\n            SRC,\n            {\n              [P in keyof DST]: SRC[P] extends '__union' & infer R ? never : P;\n            }[keyof DST]\n          >,\n          '__typename'\n        >]: IsPayLoad<DST[P]> extends true ? SRC[P] : IsArray<SRC[P], DST[P]>;\n      }\n  : {\n      [P in keyof Pick<SRC, keyof DST>]: IsPayLoad<DST[P]> extends true ? SRC[P] : IsArray<SRC[P], DST[P]>;\n    };\n\nexport type MapType<SRC, DST> = SRC extends DeepAnify<DST> ? IsInterfaced<SRC, DST> : never;\nexport type InputType<SRC, DST> = IsPayLoad<DST> extends { __alias: infer R }\n  ? {\n      [P in keyof R]: MapType<SRC, R[P]>;\n    } &\n      MapType<SRC, Omit<IsPayLoad<DST>, '__alias'>>\n  : MapType<SRC, IsPayLoad<DST>>;\ntype Func<P extends any[], R> = (...args: P) => R;\ntype AnyFunc = Func<any, any>;\nexport type ArgsType<F extends AnyFunc> = F extends Func<infer P, any> ? P : never;\nexport type OperationOptions = {\n  variables?: Record<string, any>;\n  operationName?: string;\n};\nexport type OperationToGraphQL<V, T> = <Z extends V>(o: Z | V, options?: OperationOptions) => Promise<InputType<T, Z>>;\nexport type SubscriptionToGraphQL<V, T> = <Z extends V>(\n  o: Z | V,\n  options?: OperationOptions,\n) => {\n  ws: WebSocket;\n  on: (fn: (args: InputType<T, Z>) => void) => void;\n  off: (fn: (e: { data?: InputType<T, Z>; code?: number; reason?: string; message?: string }) => void) => void;\n  error: (fn: (e: { data?: InputType<T, Z>; errors?:string[] }) => void) => void;\n  open: () => void;\n};\nexport type SelectionFunction<V> = <T>(t: T | V) => T;\nexport type fetchOptions = ArgsType<typeof fetch>;\ntype websocketOptions = typeof WebSocket extends new (\n  ...args: infer R\n) => WebSocket\n  ? R\n  : never;\nexport type chainOptions =\n  | [fetchOptions[0], fetchOptions[1] & {websocket?: websocketOptions}]\n  | [fetchOptions[0]];\nexport type FetchFunction = (\n  query: string,\n  variables?: Record<string, any>,\n) => Promise<any>;\nexport type SubscriptionFunction = (query: string) => void;\ntype NotUndefined<T> = T extends undefined ? never : T;\nexport type ResolverType<F> = NotUndefined<F extends [infer ARGS, any] ? ARGS : undefined>;\n";
